% clear all; 
close all force; clc;

% 
% myfunction = @(x, y) [...
%     x^2;
%     x*y...
%     ];

% addpath(genpath('func_Vova') ); % подключаем папку с функциями от Вовы
% addpath(genpath('My_func_aux') ); % подключаем папку с Моими функциями
% addpath(genpath('My_func_general') ); % подключаем папку с Моими функциями
addpath(genpath('OrbitalMotion')); % include folder with orbital motion functions
addpath(genpath('InertialMeasurementUnit')); % include folder with inertial measurement functions
addpath(genpath('InertialNavigationSystem')); % include folder with inertial navigation system functions
addpath(genpath('SNS')); % include folder with inertial navigation system functions
addpath(genpath('Integrated')); % include folder with integrated navigation system functions
addpath(genpath('Statistics')); % include folder with Statistics functions
addpath(genpath('TOAMeasurementUnit')); % include folder with Pulsar & Quasar navigation
addpath(genpath('StateSpaceEstimation')); % include folder with State Space Estimation algorithms
addpath(genpath('Utils'));

% w = WienerProcess([0.1; 0.09; 0.35], [0.1; 0.1; 0.3]);
% sim = w.simulate(dt, N);

filterTypeArray         = {'ukf'}; %{'ukf', 'ckf', 'srckf', 'cdkf','srukf','srcdkf'};
sampleTime              = 1; % seconds
simulationTime          = 1*60*60; % y hours * 60 min * 60 sec
simulationNumber        = round(simulationTime / sampleTime);
time                    = (1: simulationNumber) * sampleTime;
timeMinutes             = time / 60;
iterationNumber         = 1;
accBiasMu               = 1e-8*[1;1;1];
accBiasSigma            = 5e-7*[1;1;1];
accNoiseVar             = 1e-7*[1;1;1]
gyroBiasMu              = 1e-8*[1;1;1];
gyroBiasSigma           = 5e-6*[1;1;1]; 
initialAcceleration     = zeros(3,1);
initialAngularVelocity  = zeros(3,1);
initialQuaternion       = [1;0;0;0];

%%  
accelerationInBodyFrame = AccelerationInBodyFrame([0; 0; 0], ... mu
    1.2*1e-5*randn(3,1), ... sigma    
    simulationNumber, ... simulationNumber
    sampleTime ... sampleTime
);

angularVelocityInBodyFrame = AngularVelocityInBodyFrame(1e-5*randn(3, 1), ... mu
    1.2*1e-3*randn(3,1), ... sigma    
    simulationNumber, ... simulationNumber
    sampleTime ... sampleTime
);

T_till_current_epoch = 0.1465;
% initial = [-21223.9926714100; -42868.3395565589; 0; 2.58697266398439; % -1.28080278894642; 0; 1; 0; 0; 0]; % GEO sat
initial = [-6158.34755458333; -4063.45976435815; 0; 3.98653859590107; -6.04177022463943; 1.27633791914791; 1; 0; 0; 0]; % LO sat

tic;
simulator = TrajectoryPhaseSpaceSatelliteSimulator(initial, ...
    accelerationInBodyFrame, ... accelerationInBodyFrame
    angularVelocityInBodyFrame, ... angularVelocityInBodyFrame
    T_till_current_epoch);

satellitePhaseStateTrue = simulator.Simulate(time, sampleTime);

% satellitePhaseStateTrue = EquationOfMotionSolver(y0_sc_true_initial, accelerationInBodyFrame.Acceleration, angularVelocityInBodyFrame.Velocity, time, T_till_current_epoch, sampleTime);
fprintf('Simulating true trajectory: ');
toc;

SatelliteOrbitVisualization(satellitePhaseStateTrue);

%% simulate INS
satellitePhaseState = SatellitePhaseSpace(initial, simulationNumber + 1);
iterations = repmat(satellitePhaseState, iterationNumber, 1);

insInitArgs.accBiasMu                    = accBiasMu;
insInitArgs.accBiasSigma                 = accBiasSigma;
insInitArgs.gyroBiasMu                   = gyroBiasMu;
insInitArgs.gyroBiasSigma                = gyroBiasSigma;
insInitArgs.accelerationInBodyFrame      = accelerationInBodyFrame;
insInitArgs.angularVelocityInBodyFrame   = angularVelocityInBodyFrame;
insInitArgs.simulationNumber             = simulationNumber;
insInitArgs.timeMinutes                  = timeMinutes;
insInitArgs.visualize                    = 1;
insInitArgs.T_till_current_epoch         = T_till_current_epoch;
insInitArgs.sampleTime                   = sampleTime;
insInitArgs.accNoiseVar                  = accNoiseVar;
snsInitArgs.Trajectory = satellitePhaseStateTrue.Trajectory';
snsInitArgs.Velocity   = satellitePhaseStateTrue.Velocity';

initialCov = [1e2*eye(3) zeros(3, 19); ... distance error
    zeros(3, 3) 1e-2*eye(3) zeros(3, 16); ... velocity error
    zeros(4, 6) 1e-4*eye(4) zeros(4, 12); ... quaterni error
    zeros(3, 10) diag((accBiasSigma.*accBiasSigma)) zeros(3, 9); ... acceler bias
    zeros(3, 13) diag((gyroBiasSigma.*gyroBiasSigma)) zeros(3, 6); ... gyro bias
    zeros(3, 16) 1e-6*eye(3) zeros(3, 3); ... acceler scale factor
    zeros(3, 19) 1e-6*eye(3) ... acceler scale factor
];

initialState = sqrt(initialCov)*randn(22, 1);

tic;

% parfor k = 1:iterationNumber
for j = 1:length(filterTypeArray)
    estimatorType = filterTypeArray(j);
    fprintf('estimator: %s\n', estimatorType{1});
    
    for k = 1:iterationNumber    
        copyTime = time;    
        ins = initInertialNavigationSystem('init', insInitArgs);
        sns = initSatelliteNavigationSystem('init', snsInitArgs);

        gssmInsSnsInitArgs.initialParams                 = [accBiasMu; accBiasSigma; gyroBiasMu; gyroBiasSigma; initialAcceleration; initialAngularVelocity; initialQuaternion; sampleTime; time(1)];
        gssmInsSnsInitArgs.processNoiseMean              = [accBiasMu; gyroBiasMu];
        gssmInsSnsInitArgs.processNoiseCovariance        = [diag(accBiasSigma.*accBiasSigma) zeros(3,3); zeros(3,3) diag(gyroBiasSigma.*gyroBiasSigma)];
        gssmInsSnsInitArgs.observationNoiseMean          = zeros(6, 1); 
        gssmInsSnsInitArgs.observationNoiseCovariance    = [10*10*eye(3) zeros(3,3); zeros(3,3) .01*.01*eye(3)];

        insErrorDynamicStateSpaceModel = gssmInsSns('init', gssmInsSnsInitArgs);
        args.type  = 'state';
        args.tag   = 'State estimation for loosely coupled Ins & Sns integrated system';
        args.model = insErrorDynamicStateSpaceModel;

        % todo: debug inference noise generator
        [processNoise, observationNoise, inferenceDataSet] = inferenceNoiseGenerator(inferenceDataGenerator(args), estimatorType);
        
        switch estimatorType{1}
            case 'ukf'
                alpha = 1; % scale factor (UKF parameter)
                beta  = 2; % optimal setting for Gaussian priors (UKF parameter)
                kappa = 0; % optimal for state dimension=2 (UKF parameter)
                
                inferenceDataSet.spkfParams = [alpha beta kappa];
                
            case 'srukf'
                alpha = 1; % scale factor (UKF parameter)
                beta  = 2; % optimal setting for Gaussian priors (UKF parameter)
                kappa = 0; % optimal for state dimension=2 (UKF parameter)
                
                inferenceDataSet.spkfParams = [alpha beta kappa];
                Sx = chol(Px)';
                
            case 'cdkf'
                inferenceDataSet.spkfParams = sqrt(3); % scale factor (CDKF parameter h)
                
            case 'srcdkf'
                alpha = 1;         % scale factor (UKF parameter)
                beta  = 2;         % optimal setting for Gaussian priors (UKF parameter)
                kappa = 0;         % optimal for state dimension=2 (UKF parameter)
                
                Sx = chol(Px)';
                
                inferenceDataSet.spkfParams = [alpha beta kappa];
            otherwise
                % do nothing by default
        end
    %     tic;
        state = initialState;
        covState = initialCov;
        insMeasurement = initial;
        
        for i = 2:1:simulationNumber + 1          
            insMeasurement = ins.Simulate(insMeasurement, i, sampleTime, copyTime(i));
            snsMeasurement = sns.Simulate(i);
            observation = insMeasurement(1:6) - snsMeasurement;
            
            modelParams.params(1:3)    = inferenceDataSet.model.params(1:3);   % accelerationBiasMu
            modelParams.params(4:6)    = inferenceDataSet.model.params(4:6);   % accelerationBiasSigma
            modelParams.params(7:9)    = inferenceDataSet.model.params(7:9);   % gyroBiasMu
            modelParams.params(10:12)  = inferenceDataSet.model.params(10:12); % gyroBiasSigma
            modelParams.params(13:15)  = ins.GetAcceleration(i); 
            modelParams.params(16:18)  = ins.GetAngularVelocity(i);
            modelParams.params(19:22)  = insMeasurement(7:10);                 % quaternion
            modelParams.params(23)     = inferenceDataSet.model.params(23);    % sampleTime
            modelParams.params(24)     = time(i);
            
            inferenceDataSet.model.setParams(inferenceDataSet.model, modelParams);
            
            [state, covState, processNoise, observationNoise, ~] = ukf(state, covState, processNoise, observationNoise, observation, inferenceDataSet);
            iterations(k).AddPhaseState(state, i);
            % TODO: check it
            insMeasurement = insCorrection(insMeasurement, state(1:10));
        end

        SatelliteOrbitVisualization(iterations(k));
        fprintf ('thread of %d: ', k );    
    %     toc;
    end

    fprintf('Simulation: ');
    toc;

    tic;
    errorReducer = ErrorReducer(iterations, satellitePhaseStateTrue, 10, simulationNumber);
    rmsd = errorReducer.RMSD();
    display('RMSD calculation: ');
    toc;

    figure(); 
        plot(timeMinutes(2:end)', [sqrt(rmsd(:, 1))'; sqrt(rmsd(:, 2))'; sqrt(rmsd(:, 3))']); 
        title('Root-mean-square deviation displacement'); 
        ylabel('RMSD displacement, m');
        xlabel('time, min');
        legend('x axis', 'y axis', 'z axis');
        grid on;

    figure(); 
        plot(timeMinutes(2:end)', [sqrt(rmsd(:, 4))'; sqrt(rmsd(:, 5))'; sqrt(rmsd(:, 6))']); 
        title('Root-mean-square deviation velocity'); 
        ylabel('RMSD velocity, m/s');
        xlabel('time, min');
        legend('x axis', 'y axis', 'z axis');
        grid on;   
end
%%

%{
%% =========================== Инициализация случайного потока======================
%позволяет каждый раз генерировать одни и те же реализации шумов, чтобы отлаживать алгоритм
s=RandStream('mt19937ar','Seed',785);%784
RandStream.setGlobalStream(s);
% RandStream.getGlobalStream


%% =========================== Инициализация альманаха НКА======================
%Путь файла альманаха системы НКА
fileAlmanah=[cd,'\data\MCCT_140825.AGL'];   %путь к файлу альманаха
%Инициализация альманаха
alm_gln = almanah(fileAlmanah); % получаем структуру, содержащую альманах ГЛОНАССа для какой-то даты

alm_testSetilate = almanahReciver(1);%альманах менять в функции

%----------------------------------------------------------------
%% ========================= Задаём констатны ==================================
global GL_Hmin_ion%[км] высота ниже которой считается,что КА не виден 
GL_Hmin_ion=500;%[км] высота ниже которой считается,что КА не виден 

global GL_Ae %[км] - экваториальный радиус Земли
GL_Ae=6378.136;%[км] - экваториальный радиус Земли

Year_ref=1996;%опорный год, от которого отсчитываются N4 (см ИДК)
global GL_W_rot_Earth %[рад/с] - угловая скорость вращения Земли
GL_W_rot_Earth=7.2921151467e-5;%[рад/с] - угловая скорость вращения Земли

global GL_MuE%[км^3/с^2] - константа гравитационного поля Земли
GL_MuE=398600.4418;%[км^3/с^2] - константа гравитационного поля Земли

global J2_0;% - вторая зональная гармоника геопотенциала
J2_0=1082625.75e-9;% - вторая зональная гармоника геопотенциала

global GL_Temp;%[K] - температура приёмника
GL_Temp=180;%[K] - температура приёмника

global GL_T_Navig_message
GL_T_Navig_message=1e-3;%[Гц] - время навигационного 

global GL_T_chip% [сек]  - длительность 1 чипа ПСП дальномерного кода
N_chip=511;%[шт] - число чипов ПСП
GL_T_chip=GL_T_Navig_message/N_chip;% [сек]  - длительность 1 чипа ПСП дальномерного кода

global GL_Fdop_cell%[Гц] - ячейка разрешения по частоте Доплера в алгоритмах поиска и захвата
GL_Fdop_cell=500;%[Гц] - ячейка разрешения по частоте Доплера в алгоритмах поиска и захвата

global GL_DN_GLN %[дБ] диаграмма направленности НКА Глонасс

GL_DN_GLN = [0.0    11.0; 4.0    11.5; 8.0    13.0; 10.0   13.6; 12.0   14.0; 16.0   13.2; 20.0   10.8;... %new
    24.0    6.0; 28.0   -1.0; 30.0   -3.0; 36.0   -6.0; 44.0   -8.0; 50.0  -10.0; 52.0  -12.0; 54.0  -15.0; 60.0  -11.0; ...
    64.0   -7.0; 70.0   -6.0; 80.0   -7.0; 90.0   -10.0];

global GL_DN_ARN %[dB] диаграмма направленнсти КА

GL_DN_ARN = [0	14.8; 5	14.5; 10	14.0; 15	13; 20	10.5; 25	8; 30	3; 35	-6; 40	-6; 45	-2; 50	0; 55	-3;...%new
    60	-6; 65	-18; 70	-12;75	-10; 80	-12; 85	-18; 90	-30];

global GL_DN_ARN_LO %[dB] диаграмма направленнсти КА для НО
GL_DN_ARN_LO = [90 3;100 3;110 3;120 3;130 3;140 3;150 3; 160 3;170 3;180 3];% 190	3; 200	3; 210	3; 220	3;230 3;240	3;250 3;260	3; 270	3];%[dB] диаграмма направленнсти КА на НО или в перигее


global GL_Threshold;%[dB-Hz] - порог при котором будет считаться, что спутник обнаружен или нет
GL_Threshold=33;%[dB-Hz] - порог при котором будет считаться, что спутник обнаружен или нет !!!!!!!!!!!!

%================================
%% C_N0=GL_Threshold%40;%[дБ-Гц] -             энергетика вх сигнала !!!!!!!!!!!!!!!!!!!!
% C_N0=40;%[дБ-Гц] -                                      энергетика вх сигнала !!!!!!!!!!!!!!!!!!!!
C_N0=zeros(24,1);%[дБ-Гц] -                                      энергетика вх сигнала !!!!!!!!!!!!!!!!!!!!
C=40;

%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
N_stat=1;%число реализаций для набора статистики !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

time_refresh_data=15*60;%[сек] = 15мин - время, через которое необходимо обновлять данные о воздействиях Луны и Солнца
time_sat_change=60;%[сек] время, через которое мы меняем НКА

date_formatIn = 'dd.mm.yyyy'; %формат ввода данных о дате
time_formatIn = 'HH:MM:SS.FFF'; %формат ввода данных о времини

 %!!!!!!!!!!!!!!!!!!!!!!!!!!!
% T_dT_corr=1;%[сек] - интервал времени, внутри которого будет происходить фильтрация координат КА=sc
T_dT_sc=1/400*1e0;%[сек] - интервал дискретизации по времени, с которым мы будем решать ДУ для вычисления координат НКА=nsc. Так же это интервал времени, с которым идут квадратуры!!!
T_accum=1e-3;%T_dT_sc;%время инегрирования
T_dT_U=15000*1e-3;%[сек] - время выработки управления

Vmax_err=0.04;%[км/с] - СКО ошибки начальной точи траектории по скорости
Rmax_err=0.25;%[км] - СКО ошибки начальной точи траектории по положению

%% ===================== Задаём начальные условия ================================

time_ref='14:30:00.000';%время начала вычисления
time_end_eval='14:35:00.00';%время в РАССЧЁТНОЙ точке (МОСКОВСКОЕ!!!!! МДВ)

date_start_eval_mass=datevec(time_ref,time_formatIn);%массив с временем, на которое нам надо вычислить 

fields_date=fieldnames(alm_gln.date);%выяснили,какие поля есть в сруктуре с датой из альманаха
for i=1:size(fields_date,1)
    date_start_eval_mass(4-i)=alm_gln.date.( char( fields_date(i) ) ); % окончательно заполнили массив с датой и начальным временем расчёта
end;

date_end_eval =[date_start_eval_mass(1:2) date_start_eval_mass(3)+0];%дата в РАССЧЁТНОЙ точке (МОСКОВСКОЕ!!!!! МДВ) %!!! МЕНЯТЬ ПРИ НЕОБХОДИМОСТИ. Добавляя 1 к 3ем члену-увеличиваем на 1 число

Date_end_eval_mass=datevec(time_end_eval,time_formatIn);%массив с временем в РАССЧЁТНОЙ точке
Date_end_eval_mass(1:3)=date_end_eval(:);%конечный массив с ДАТОЙ и ВРЕМЕНЕМ в РАССЧЁТНОЙ точке

clear i
%----------------------------------------------------------------
%% ====================== Расчёт временных интервалов===========================

N4=fix( (date_start_eval_mass(1)-Year_ref)/4 )+1;%N4 - номер интервала по 4 года(между каждыми високосными) в котором находится текущая дата
%в функцие datenum формат данных: yyyy.mm.dd
Nt=datenum( date_start_eval_mass(1:3) ) - datenum([Year_ref+(N4-1)*4 1 1])+1;%Nt - номер суток внутри 4хлетнего високосного периода

% [Day_cur, Month_cur, Year_cur]=N4Nt2currentDate(N4,Nt);%пересчёт даты из формата N4 и Nt в формат dd.mm.yyyy

JD=JD_count_fun(N4,Nt);%вычисляем текущую Юлианскую дату

Delta_dateNtime=Date_end_eval_mass-date_start_eval_mass;%расчитываем разницу во времени м/у датой и временем конца вычислений и начальной датой и временем

T_Ttotal_eval=Delta_dateNtime(3)*3600*24+T_fun( Delta_dateNtime(4:6) );%[сек] - число секунд в этой разнице

T_Tstart=0*T_fun( date_start_eval_mass(4:6) );%[сек] - вычисляем время закладки эфемерид(момент начала вычислений)
T_Tend=T_Ttotal_eval+T_Tstart;


clear Delta_dateNtime

%----------------------------------------------------------------
%% ==================== Вычисление координат НКА и КА на заданом интервале=====================

nsmax = 24;           %кол-во моделируемых спутников

%=========расчёт истиной траектории КА и НКА и пересчёт их из Гринвечской СК в Инерциальную СК============

tic
[Satpos_xyz_Rec_mean,Satpos_xyz_gln,Sun,Moon] = SC_and_NSC_trajectory_calc(...
    T_Ttotal_eval,...
    T_dT_sc, ...
    time_refresh_data, ...
    JD, ...
    T_Tstart, ...
    T_Tend, ...
    alm_testSetilate, ...
    date_start_eval_mass, ...
    Nt,alm_gln);
toc
figure(); plot(Satpos_xyz_Rec_mean.x);
figure(); plot(Satpos_xyz_Rec_mean.y);
figure(); plot(Satpos_xyz_Rec_mean.z);
figure(); plot(Satpos_xyz_Rec_mean.vx);
figure(); plot(Satpos_xyz_Rec_mean.vy);
figure(); plot(Satpos_xyz_Rec_mean.vz);
figure(); plot(Satpos_xyz_Rec_mean.q);
figure(); plot(Satpos_xyz_Rec_mean.qi);
figure(); plot(Satpos_xyz_Rec_mean.qj);
figure(); plot(Satpos_xyz_Rec_mean.qk);
return
%{
%----------------------------------------------------------------------
%% =======Расчитываем траектории КА с разными случайными отклонениями от средней======================
%орбиты для набора статистики
N_max=T_Ttotal_eval/T_dT_sc+1;% полное число точек траектории полёта
Satpos_xyz_Rec_current(1:N_stat)=struct('x',zeros(1,N_max),'y',zeros(1,N_max),'z',zeros(1,N_max),'vx',zeros(1,N_max),'vy',zeros(1,N_max),'vz',zeros(1,N_max));
State_space_error=zeros(6,N_stat);

% matlabpool open %для параллельных вычислений

tic
for i=1:N_stat
    State_space_error(:,i)=1*[Rmax_err*randn; Rmax_err*randn; Rmax_err*randn; Vmax_err*randn; Vmax_err*randn; Vmax_err*randn];%Ошибка по координатам и скоростям в начальный момент времени!!!!!!!!!!!!!!!
%     State_space_error(:,i)=[-0.379039417699431;0.213644210733933;0.390210249361874;-0.0220798398887709;0.0939310296257019;0.00691360219067245];
    
    while sqrt( sum( ( ( State_space_error(4:6,i) ).*1000).^2 ) )>120;
        State_space_error(4:6,i)=[Vmax_err*randn; Vmax_err*randn; Vmax_err*randn];%Ошибка по координатам и скоростям в начальный момент времени!!!!!!!!!!!!!!!
    end;
    
    y0_sc_current=[Satpos_xyz_Rec_mean.x(1);Satpos_xyz_Rec_mean.y(1);Satpos_xyz_Rec_mean.z(1);...
                             Satpos_xyz_Rec_mean.vx(1);Satpos_xyz_Rec_mean.vy(1);Satpos_xyz_Rec_mean.vz(1)]+...
                             State_space_error(:,i);% задаём начальные условия для ДУ  

   Satpos_xyz_Rec_current(i)=SC_current_trajectory_calc(T_Ttotal_eval,time_refresh_data,T_dT_sc,T_Tstart,T_Tend,...
        Sun,Moon,y0_sc_current);                      
    
end;
toc
% matlabpool close %для параллельных вычислений

% r_sc_current=sqrt( Satpos_xyz_Rec_current.x(:).^2+Satpos_xyz_Rec_current.y(:).^2+Satpos_xyz_Rec_current.z(:).^2 )-GL_Ae;
% figure;
% plot(r_sc_current);

% r_sc_mean=sqrt( Satpos_xyz_Rec_mean.x(:).^2+Satpos_xyz_Rec_mean.y(:).^2+Satpos_xyz_Rec_mean.z(:).^2 )-GL_Ae;
% figure;
% plot(r_sc_mean);


%{
% R=zeros(1,N_max);

Err_coord=Coord_Inert_sc_true-Coord_Inert_sc_current;%вычисляем отличие текущей координаты от истинной
Err_vel=Vel_Inert_sc_true-Vel_Inert_sc_current;%вычисляем отличие текущей скорости от истинной

r_sc_true=sqrt( Coord_Inert_sc_true(1,:).^2+Coord_Inert_sc_true(2,:).^2+Coord_Inert_sc_true(3,:).^2 )-GL_Ae;
r_sc_current=sqrt( Coord_Inert_sc_current(1,:).^2+Coord_Inert_sc_current(2,:).^2+Coord_Inert_sc_current(3,:).^2 )-GL_Ae;
r_nsc=sqrt( Coord_Inert_nsc_gln(1,:).^2+Coord_Inert_nsc_gln(2,:).^2+Coord_Inert_nsc_gln(3,:).^2 )-GL_Ae;
%}

clear Vel_Inert_sc_current Coord_Inert_sc_current Vel_Inert_sc_true Coord_Inert_sc_true ti_current i K k Y 
clear Sun Moon start stop Vel_Inert_nsc_gln Coord_Inert_nsc_gln y0_sc ns S date_current_time_mass r_nsc
clear hour minute sec month ERA GMST j y0_sc_true time_formatIn flag r_sc_true r_sc_current
clear Err_vel Err_coord Ti_current
clear y0_sc_current
%% ========Вычисление видимости спутников, задержки сигнала и доплеровского сдвига================


   
Out_param_current(1:nsmax,N_stat)=struct('vis',[],'Power',[],'Tz',[],'N_navig',[],'N_chip_Tau',[],'T_chip_resid',[],'T_navig_resid',[],'Fdop_1',[],'N_chip_Fdop',[],'Phi_HF_1',[],'cH',[],'Litera',[],'delta_fi0',[],'d_fd_dt',[]);
Out_param_mean(1:nsmax,1)=struct('vis',[],'Power',[],'Tz',[],'N_navig',[],'N_chip_Tau',[],'T_chip_resid',[],'T_navig_resid',[],'Fdop_1',[],'N_chip_Fdop',[],'Phi_HF_1',[],'cH',[],'Litera',[],'delta_fi0',[],'d_fd_dt',[]);
Visible_satellites=zeros(nsmax,N_max,N_stat);
Visible_satellites_reserv=zeros(nsmax,N_max,N_stat);


%Вычисляются ОСНОВНЫЕ параметры сигнала - задержка, доплер, видимость, число
%целых чипов в этой задержке

tic
for i=1:N_stat
    v_fd=zeros(nsmax,N_max);
    for ns = 1:nsmax
        
        [Out_param_current(ns,i)] = Calc_param(Satpos_xyz_Rec_current(i), Satpos_xyz_gln(ns), alm_gln, ns);%ф-ция вычисления параметров
%         [Out_param_current(ns,i)] = Calc_param(Satpos_xyz_Rec_mean, Satpos_xyz_gln(ns), alm_gln, ns);%ф-ция вычисления параметров
              
        Visible_satellites(ns,:,i)=Out_param_current(ns,i).vis;%находим массив видимых спутников
        
        delta_fi0=zeros(1,N_max);
        v_fd(ns,1:N_max-1)=diff(Out_param_current(ns,i).Fdop_1)/T_dT_sc;%[Гц/с]
        v_fd(ns,N_max)=v_fd(ns,N_max-1);
        Fdop_1=Out_param_current(ns,i).Fdop_1(:);
        
        delta_fi0(1)=2*pi*rand;%pi/2+10/180*pi*randn(1);%+T_dT_sc.*Fdop_1(1)*2*pi;
        for jj=2:N_max%формируем фазу в корреляторе
          delta_fi0(jj)=delta_fi0(jj-1)+T_dT_sc.*Fdop_1(jj-1)*2*pi+(T_dT_sc.^2./2).*v_fd(ns,jj-1)*2*pi; 
        end;      
        
        
        Out_param_current(ns,i).d_fd_dt=v_fd(ns,:);
        Out_param_current(ns,i).delta_fi0=delta_fi0;
          
%         rrrr(1)=Out_param_current(ns,i).delta_fi0(1);
%         rrrr(2:N_max)=Out_param_current(ns,i).delta_fi0(1)+time_mass.*Out_param_current(ns,i).Fdop_1(1:end-1)*2*pi+...
%             (time_mass.^2./2).*v_fd*2*pi;
          
    end;
end
toc


for ns = 1:nsmax
    [Out_param_mean(ns,1)] = Calc_param(Satpos_xyz_Rec_mean, Satpos_xyz_gln(ns), alm_gln, ns);%ф-ция вычисления параметров
end;

%-----------------------------------
%Удаляем НКА с одинаковыми литерами

tic
for i=1:N_stat
    
    [Visible_satellites(:,:,i),Out_param_current(:,i)]=double_NSC_discard_alg(nsmax,alm_gln,Visible_satellites(:,:,i),Out_param_current(:,i));    
    
end;
toc

%--------------------------------------------------
%каждую 1 сек выбираем по 3 НКА из видимых для проверки работоспособности по 3 НКА
%{
visual=0;%строим или нет график при рассчёте GDOP

G=zeros(N_stat,N_max);
flag=1;
warning('off','MATLAB:nearlySingularMatrix');
warning('off','MATLAB:singularMatrix');
for i=1:N_stat
    while flag
        %выбираю 4 случайных НКА
        Visible_satellites_reserv(:,:,i)=NKA_selectioon(Visible_satellites(:,:,i),N_max,T_dT_sc,time_sat_change);
        for ns=1:nsmax
            Out_param_current(ns,i).vis(1:end)=Visible_satellites_reserv(ns,:,i);    
        end;
        G(i,:)=GDOP_new(Out_param_current(:,i),T_dT_sc,visual);
        if isempty( find(G(i,:)>20,1) )%проверяем, плохой ли геометрический фактор, если да, то выбирае заново
            flag=0;
            Visible_satellites(:,:,i)=Visible_satellites_reserv(:,:,i);
        end;
    end;
    flag=1;
end;
warning('on','MATLAB:nearlySingularMatrix');
warning('on','MATLAB:singularMatrix');
%}
%--------------------------------------------------


%
visual=1;%строим или нет график при рассчёте GDOP

warning('off','MATLAB:nearlySingularMatrix');
warning('off','MATLAB:singularMatrix');
tic
GDOP_new(Out_param_current(:,1),T_dT_sc,visual);
toc
warning('on','MATLAB:nearlySingularMatrix');
warning('on','MATLAB:singularMatrix');


clear visual Err_Tau0 Err_Fdop0 K_new ns N_int_sec observ_quant num_sat num_sat2 select_sat_num combinations num_sat n_vis Visible_satellites_reserv 
clear v_fd
%}
%% ============================Посторение орбит=================================
%построение орбит
%{
T1=1;%начальный индекс для построения
T2=10*1000;%конечный индекс для построения
t_refresh=10;%число отсчётов, через которое будет строиться карта видимых НКА
satellite_orbit_visualization(T1,T2,t_refresh,Satpos_xyz_Rec_mean,Satpos_xyz_gln,Visible_satellites,nsmax)%процедура построения орбит
%}



%{
Литература:

1. ИДК Глонасс v5.1 2008 - правленная (2013-14гг)
2. Г.С. Шарыгин, "Статистическая структура поля УКВ за горизонтом", М:радио и связь, 1983 - не используется
3. Rudolph van der Merwe, "Sigma-Point Kalman Filters for Probabilistic Inference in Dynamic State-Space Models" PhD Thesis, 2004
4. В.И. Тисленко, "Статистическая теория радиотехнических систем", 2007 г 
5. Chun Yang, "GPS Signal tracking with Kalman Filter based on joint code delay and carrier phase and frequency error discriminator" , ION 60th meeting 2004
6. А.И. Перов, В.Н. Харисов, "Глонасс принципы построения и функционирования", изд 4ое, М:"Радиотехника", 2010.г
7. П.Е. Эльясберг, "Введение в теорию полётов искусственных спутников земли", М, 1965  г
8. Распределение Райса: http://en.wikipedia.org/wiki/Rice_distribution
9. В.И. Меркулов и др "Оценивание дальности и скорости в РЛС", М.,Радиотехника, 2004 %расходимость ?????????? - не используется (пока)
10. В.П. Ипатов, Ю.М. Казаринов и др. "Поиск, обнаружение и измерение параметров сигналов в радионавиг. сис. (РНС)", М., "Сов. Радио", 1975, 296с. %квадратичный / линейный детектор
11. Вязл из журнала у Тисленко % СПМ шумов генератора
12. найти статью про дискриминаторы с fast и slow компонентами
13. Lecture notes on state estimation of nonlinear non-Gaussian stochastic systems %вычисление границы Крамера-Рао [12]
14. что-нибудь по разложению ф-ций Бесселя в ряды
15. PSIAKI,2002, EKF methods for traking weak GPS signals
16.
%}



%}