function [ estimate, dataSet, stateNoise, observNoise ] = gspf( dataSet, stateNoise, observNoise, observation, control1, control2, model )
    % gspf. Gaussian Sum Particle Filter.
    %
    %   [ estimate, dataSet, stateNoise, observNoise ] = gspf( dataSet, stateNoise, observNoise, observation, control1, control2, model )
    %
    %   The filter approximate the filtering and predictive distributions by weighted Gaussian mixtures and are basically
    %   banks of Gaussian particle filters. Then, we extend the use of Gaussian particle filters and Gaussian sum particle filters to
    %   dynamic state space (DSS) models with non-Gaussian noise. With non-Gaussian noise approximated by Gaussian mixtures, the non-Gaussian
    %   noise models are approximated by banks of Gaussian noise models, and Gaussian mixture filters are developed using
    %   algorithms developed for Gaussian noise models.
    %
    %   For more details please see:
    %       Jayesh H. Kotecha and Petar M. Djuric, "Gaussian Sum Particle Filtering for Dynamic State Space Models",
    %       Proceedings of ICASSP-2001, Salt Lake City, Utah, May 2001.
    %
    %   This filter assumes the following standard state-space model:
    %
    %     x(k) = f[x(k-1), v(k-1), u1(k-1)];
    %     z(k) = h[x(k), n(k), u2(k)],
    %
    %   where:
    %       x   is the system state;
    %       v   the process noise;
    %       n   the observation noise;
    %       u1  the exogenous input to the state;
    %       f   the transition function;
    %       u2  the exogenous input to the state observation function;
    %       z   the noisy observation of the system.
    %
    %   INPUT
    %         dataSet           particle filter data structure. Contains set of particles as well as their corresponding weights;
    %         stateNoise        process noise data structure;
    %         observNoise       observation noise data structure;
    %         observation       noisy observations at time k ( z(k) );
    %         control1          exogenous input to state transition function at time k-1 ( u1(k-1) );
    %         control2          exogenous input to state observation function at time k ( u2(k) );
    %         model             inference data structure, which fully describes filtration issue (generated by inferenceDataGenerator function).
    %
    %   OUTPUT
    %         estimate          state estimate generated from posterior distribution of state given all observation;
    %         dataSet           updated Particle filter data structure. Contains set of particles as well as their corresponding weights;
    %         stateNoise        process noise data structure (possibly updated);
    %         observNoise       observation noise data structure (possibly updated).
    %
    %   dataSet fields:
    %         .particlesNum        number of particles;
    %         .particles           particle buffer (statedim-by-N matrix);
    %         .weights             particle weights (1-by-N r-vector).
    %
    %   Required model fields:
    %         .estimateType        estimate type : 'mean', 'mode', etc;
    %         .resampleThreshold   if the ratio of the 'effective particle set size' to the total number of particles
    %                              drop below this threshold  i.e. (nEfective / particlesNum) < resampleThreshold
    %                              the particles will be resampled. (nEfective is always less than or equal to particlesNum).
    %
    %% error checking
    if nargin ~= 7
        error('[ gspf ] Incorrect number of input arguments.');
    end
    
    if ~strcmp(stateNoise.noiseSourceType, 'gmm')
        error('[ gspf ] Process noise source must be of type : gmm (Gaussian Mixture Model)');
    end
    
    if ~strcmp(dataSet.stateGMM.covarianceType, {'sqrt', 'sqrt-diag'})
        error('[ gspf ] state GMMs should have ''sqrt'' or ''sqrt-diag'' covariance type.');
    end
    %%
    x_dim  = model.stateDimension;
    v_dim  = model.processNoiseDimension;                                % extract process noise dimension
    
    num = dataSet.particlesNum;
    stateGMM = dataSet.stateGMM;
    
    G    = stateGMM.mixtureCount;      % number of components in state GMM
    K    = stateNoise.mixtureCount;        % number of components in process noise GMM
    
    GK  = G*K;
    
    sampleBuf1 = zeros(x_dim,num,G);     % sample buffer : (sample dimension) X (number of samples) X (number of mixcomps)
    sampleBuf2 = zeros(x_dim,num,GK);
    stateWNew = zeros(1,GK);
    
    sampleBuf3 = zeros(x_dim,num,GK);
    impWeights = zeros(GK,num);
    
    stateMu  = stateGMM.mean;
    stateCov = stateGMM.covariance;
    stateW   = stateGMM.weights;
    
    stateMuNew  = zeros(x_dim,GK);
    stateCovNew = zeros(x_dim,x_dim,GK);
    
    pNoiseW = stateNoise.weights;
    
    ones_numP = ones(num, 1);
    ones_Xdim = ones(1, x_dim);
            
    if (model.controlInputDimension == 0)
        control1 = [];
    end
    
    if (model.control2InputDimension == 0)
        control2 = [];
    end
    
    
    OBS = observation(:,ones_numP);
    
    %% TIME UPDATE
    % draw M samples from each state GMM component
    for g=1:G
        temp_mu = stateMu(:, g);
        % It is assumed that the covariances are Cholesky factors
        sampleBuf1(:,:,g) = stateCov(:,:,g) * randn(x_dim,num) + temp_mu(:,ones_numP);
    end
    
    % get process noise GMM component covariance
    for k=1:K
        cS  = stateNoise.covariance(:, :, k);
        cMu = stateNoise.mean(:, k);
        cMuBuf = cMu(:, ones_numP);
        for g=1:G
            gk = g + (k-1)*G;
            pNoiseBuf = cS * randn(v_dim,num) + cMuBuf;
            sampleBuf2(:,:,gk) = model.stateTransitionFun( model, sampleBuf1(:,:,g), pNoiseBuf, control1);
            stateWNew(1,gk) = stateW(1,g) * pNoiseW(1,k);
        end
    end
    
    stateWNew = stateWNew / sum(stateWNew);
    
    % inline sample mean and covariance
    for gk=1:GK
        muFoo = sum(sampleBuf2(:,:,gk),2)/num;
        stateMuNew(:,gk) = muFoo;
        muFoo = muFoo(:,ones_numP);
        Xfoo = sampleBuf2(:,:,gk) - muFoo;
        [~, covFoo] = qr(Xfoo',0);
        stateCovNew(:,:,gk) = covFoo'/sqrt(num-1);
    end
    
    
    %% MEASUREMENT UPDATE
    % Calculate observed samples and importance weights
    for gk=1:GK,
        temp_mu = stateMuNew(:,gk);
        sampleBuf3(:,:,gk) = stateCovNew(:,:,gk) * randn(x_dim,num) + temp_mu(:,ones_numP);
        impWeights(gk,:) = model.likelihoodStateFun( model, OBS, sampleBuf3(:,:,gk), control2, observNoise) + 1e-99;
    end
    
    weightNorm = 0;
    
    % Calculate updated state mixcomp means, covariances and weights
    for gk=1:GK
        
        weightFoo = impWeights(gk,:);
        impWeightM = weightFoo(ones_Xdim,:);   % inline rvecrep
        impWeightNorm = sum(weightFoo);
        muFoo2 = sum(impWeightM.*sampleBuf3(:,:,gk),2) / impWeightNorm;
        stateMuNew(:,gk) = muFoo2;
        
        xdel = sampleBuf3(:,:,gk) - muFoo2(:,ones_numP); % inline cvecrep
        weightSFoo = sqrt(weightFoo);
        impWeightSM = weightSFoo(ones_Xdim,:);
        
        Xfoo = impWeightSM.*xdel;
        
        [~,covFoo] = qr(Xfoo',0);
        stateCovNew(:,:,gk) = covFoo'/sqrt(impWeightNorm);
        
        stateWNew(:,gk) = stateWNew(:,gk)*impWeightNorm;   % part 1 of equation (11)
        weightNorm = weightNorm + impWeightNorm;
    end
    
    % Calculate updated and normalized mixcomp weights
    stateWNew = stateWNew / weightNorm;                   % part 2 of equation (11)
    stateWNew = stateWNew / sum(stateWNew);               % normalize
    
    %-----------------------------------------------------------------------
    % CALCULATE ESTIMATE
    
    %% calculate estimate
    if strcmp(model.estimateType, 'mean')
        estimate = sum(stateWNew(ones_Xdim,:).*stateMuNew,2);
    else
        error('[ gmsppf::model::estimateType ] Unknown estimate type.');
    end
    
    
    %% RESAMPLE MIXTURE COMPONENTS
    resampleIdx = residualResample(1:GK,stateWNew);
    [~, rIdx] = sort(rand(1,GK));
    rIdx=rIdx(1:G);
    
    idx = resampleIdx(rIdx);
    stateMu = stateMuNew(:,idx);
    stateCov = stateCovNew(:,:,idx);
    
    stateW = (1/G) * ones(1,G);
    
    dataSet.stateGMM.covariance = stateCov;
    dataSet.stateGMM.mean       = stateMu;
    dataSet.stateGMM.weights    = stateW;
end
