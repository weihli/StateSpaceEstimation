function [ estimate, dataSet, stateNoise, observNoise ] = gspf( dataSet, stateNoise, observNoise, observation, control1, control2, model )
    % gspf. Gaussian Sum Particle Filter.
    %
    %   [ estimate, dataSet, stateNoise, observNoise ] = gspf( dataSet, stateNoise, observNoise, observation, control1, control2, model )
    %
    %   The filter approximate the filtering and predictive distributions by weighted Gaussian mixtures and are basically
    %   banks of Gaussian particle filters. Then, we extend the use of Gaussian particle filters and Gaussian sum particle filters to
    %   dynamic state space (DSS) models with non-Gaussian noise. With non-Gaussian noise approximated by Gaussian mixtures, the non-Gaussian
    %   noise models are approximated by banks of Gaussian noise models, and Gaussian mixture filters are developed using
    %   algorithms developed for Gaussian noise models.
    %
    %   For more details please see:
    %       Jayesh H. Kotecha and Petar M. Djuric, "Gaussian Sum Particle Filtering for Dynamic State Space Models",
    %       Proceedings of ICASSP-2001, Salt Lake City, Utah, May 2001.
    %
    %   This filter assumes the following standard state-space model:
    %
    %     x(k) = f[x(k-1), v(k-1), u1(k-1)];
    %     z(k) = h[x(k), n(k), u2(k)],
    %
    %   where:
    %       x   is the system state;
    %       v   the process noise;
    %       n   the observation noise;
    %       u1  the exogenous input to the state;
    %       f   the transition function;
    %       u2  the exogenous input to the state observation function;
    %       z   the noisy observation of the system.
    %
    %   INPUT
    %         dataSet           particle filter data structure. Contains set of particles as well as their corresponding weights;
    %         stateNoise        process noise data structure;
    %         observNoise       observation noise data structure;
    %         observation       noisy observations at time k ( z(k) );
    %         control1          exogenous input to state transition function at time k-1 ( u1(k-1) );
    %         control2          exogenous input to state observation function at time k ( u2(k) );
    %         model             inference data structure, which fully describes filtration issue (generated by inferenceDataGenerator function).
    %
    %   OUTPUT
    %         estimate          state estimate generated from posterior distribution of state given all observation;
    %         dataSet           updated Particle filter data structure. Contains set of particles as well as their corresponding weights;
    %         stateNoise        process noise data structure (possibly updated);
    %         observNoise       observation noise data structure (possibly updated).
    %
    %   dataSet fields:
    %         .particlesNum        number of particles;
    %         .particles           particle buffer (statedim-by-N matrix);
    %         .weights             particle weights (1-by-N r-vector).
    %
    %   Required model fields:
    %         .estimateType        estimate type : 'mean', 'mode', etc;
    %         .resampleThreshold   if the ratio of the 'effective particle set size' to the total number of particles
    %                              drop below this threshold  i.e. (nEfective / particlesNum) < resampleThreshold
    %                              the particles will be resampled. (nEfective is always less than or equal to particlesNum).
    %
    %% error checking
    if nargin ~= 7
        error('[ gspf ] Incorrect number of input arguments.');
    end
    
    if ~strcmp(stateNoise.noiseSourceType, 'gmm')
        error('[ gspf ] Process noise source must be of type : gmm (Gaussian Mixture Model)');
    end
    
    if ~strcmp(dataSet.stateGMM.covarianceType, {'sqrt', 'sqrt-diag'})
        error('[ gspf ] state GMMs should have ''sqrt'' or ''sqrt-diag'' covariance type.');
    end
    %%
    x_dim  = model.stateDimension;
    num = dataSet.particlesNum;
    
    xMixcompsCnt        = dataSet.stateGMM.mixtureCount;
    xNoiseMixcompsCnt   = stateNoise.mixtureCount;
    mixcompsCnt         = xMixcompsCnt*xNoiseMixcompsCnt;
    
    % sample buffer : (sample dimension) X (number of samples) X (number of mixcomps)
    xBuf1 = zeros(x_dim, num, xMixcompsCnt);
    xBuf2 = zeros(x_dim, num, mixcompsCnt);
    xBuf3 = zeros(x_dim, num, mixcompsCnt);
    
    xWeigthsNew = zeros(1, mixcompsCnt);
    importanceW = zeros(mixcompsCnt, num);
    stateMuNew  = zeros(x_dim, mixcompsCnt);
    stateCovNew = zeros(x_dim, x_dim, mixcompsCnt);
    
    ones_num = ones(num, 1);
    ones_xdim = ones(1, x_dim);
    
    if (model.controlInputDimension == 0)
        control1 = [];
    end
    
    if (model.control2InputDimension == 0)
        control2 = [];
    end
    
    obs = observation(:, ones_num);
    %% Time update
    for g = 1 : xMixcompsCnt
        mean = dataSet.stateGMM.mean(:, g);
        xBuf1(:, :, g) = dataSet.stateGMM.covariance(:, :, g) * randn(x_dim, num) + mean(:, ones_num);
    end
    
    for k = 1 : xNoiseMixcompsCnt
        meanMixcomps = stateNoise.mean(:, k);
        for g = 1 : xMixcompsCnt
            gk = g + (k-1)*xMixcompsCnt;
            xNoiseBuf = (stateNoise.covariance(:, :, k)) * randn(model.processNoiseDimension, num) + meanMixcomps(:, ones_num);
            xBuf2(:, :, gk) = model.stateTransitionFun(model, xBuf1(:,:,g), xNoiseBuf, control1);
            xWeigthsNew(1, gk) = dataSet.stateGMM.weights(1, g) * stateNoise.weights(1, k);
        end
    end
    
    xWeigthsNew = xWeigthsNew / sum(xWeigthsNew);
    
    for g = 1 : mixcompsCnt
        mu1 = sum(xBuf2(:,:,g),2)/num;
        stateMuNew(:,g) = mu1;
        mu1 = mu1(:, ones_num);
        [~, covFoo] = qr( (xBuf2(:,:,g) - mu1)', 0 );
        stateCovNew(:, :, g) = covFoo' / sqrt(num - 1);
    end
    
    %% MEASUREMENT UPDATE
    for g = 1 : mixcompsCnt,
        mean = stateMuNew(:, g);
        xBuf3(:, :, g) = stateCovNew(:, :, g) * randn(x_dim, num) + mean(:, ones_num);
        importanceW(g, :) = model.likelihoodStateFun(model, obs, xBuf3(:, :, g), control2, observNoise) + 1e-99;
    end
    
    weightNorm = 0;
    for g = 1 : mixcompsCnt
        tmp_w = importanceW(g, :);
        impWeightNorm = sum(tmp_w);
        mu2 = sum( tmp_w(ones_xdim,:) .* xBuf3(:, :, g), 2) / impWeightNorm;
        stateMuNew(:, g) = mu2;
        
        w = sqrt(tmp_w);
        [~, covFoo] = qr( ( w(ones_xdim, :) .* (xBuf3(:, :, g) - mu2(:, ones_num)) )', 0 );
        stateCovNew(:, :, g) = covFoo' / sqrt(impWeightNorm);
        
        xWeigthsNew(:, g) = xWeigthsNew(:, g)*impWeightNorm;
        weightNorm = weightNorm + impWeightNorm;
    end
    
    xWeigthsNew = xWeigthsNew / weightNorm;
    xWeigthsNew = xWeigthsNew / sum(xWeigthsNew);
    
    %%
    if strcmp(model.estimateType, 'mean')
        estimate = sum(xWeigthsNew(ones_xdim, :) .* stateMuNew, 2);
    else
        error('[ gmsppf::model::estimateType ] Unknown estimate type.');
    end
    
    %% Resample mixture components
    idx  = resampleMixtureComponents(xNoiseMixcompsCnt, xMixcompsCnt, xWeigthsNew, model.resampleMethod);
    
    dataSet.stateGMM.covariance = stateCovNew(:, :, idx);
    dataSet.stateGMM.mean       = stateMuNew(:, idx);
    dataSet.stateGMM.weights    = ones(1, xMixcompsCnt) / xMixcompsCnt;
end
