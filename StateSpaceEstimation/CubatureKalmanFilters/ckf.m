function [newState, newCovState, stateNoise, observNoise, internal ] = ckf(state, covState, stateNoise, observNoise, observation, model, control1, control2)
% CKF  Cubature Kalman Filter (subclass of Sigma Point Kalman Filter)
%
%   [newState, newCovState, stateNoise, observNoise, internal ] = ckf(state, covState, stateNoise, observNoise, observation, gssModel, control1, control2)
%
%   This filter assumes the following standard state-space model:
%
%     x(k) = f[x(k-1), v(k-1), U1(k-1)]
%     y(k) = h[x(k), n(k), U2(k)]
%
%   where:
%       x  - is the system state,
%       v  - the process noise,
%       n  - the observation noise,
%       u1 - the exogenous input to the state
%       f  - the transition function,
%       u2 - the exogenous input to the state observation function
%       y  - the noisy observation of the system.
%
%   INPUT
%         state         state mean at time k-1          ( xh(k-1) )
%         covState      state covariance at time k-1    ( Px(k-1) )
%         stateNoise    state noise data structure     (must be of type 'gaussian' or 'combo-gaussian')
%         observNoise   observation noise data structure (must be of type 'gaussian' or 'combo-gaussian')
%         observation   noisy observations starting at time k ( y(k),y(k+1),...,y(k+N-1) )
%         control1      exogenous input to state transition function starting at time k-1 ( u1(k-1),u1(k),...,u1(k+N-2) )
%         control2      exogenous input to state observation function starting at time k  ( u2(k),u2(k+1),...,u2(k+N-1) )
%         model         inference data structure generated by GENINFDS function.
%
%   OUTPUT
%         newState     estimates of state starting at time k ( E[x(t)|y(1),y(2),...,y(t)] for t=k,k+1,...,k+N-1 )
%         newStateCov  state covariance
%         stateNoise   state noise data structure     (possibly updated)
%         observNoise  observation noise data structure (possibly updated)
%
%         internal                      <<optional>> internal variables data structure
%           .meanPredictedState         	predicted state mean ( E[x(t)|y(1),y(2),..y(t-1)] for t=k,k+1,...,k+N-1 )
%           .predictedStateCov              predicted state covariance
%           .predictedObservMean            predicted observation ( E[y(k)|Y(k-1)] )
%           .inov                           inovation signal
%           .predictedObservCov             inovation covariance
%           .filterGain                     Kalman gain
%
    %% ERROR CHECKING
    if (nargin ~= 8 && nargin ~= 6); error(' [ ckf ] Not enough input arguments (should be 6 or 8).'); end

    if (model.stateDimension ~= size(state, 1)); error('[ ckf ] Prior state dimension differs from model.stateDimension'); end

    if (model.stateDimension ~= size(covState, 1)); error('[ ckf ] Prior state covariance dimension differs from model.stateDimension'); end

    if (model.observationDimension ~= size(observation, 1)); error('[ ckf ] Observation dimension differs from model.observationDimension'); end

    %%
    stateDim         = model.stateDimension;
    stateNoiseDim    = model.processNoiseDimension;
    obsNoiseDim      = model.observationNoiseDimension;
        
    augmentDim = stateDim + stateNoiseDim;
    numCubPointSet1 = 2*augmentDim;
    
    if (model.controlInputDimension == 0); control1 = []; end

    %% Calculate cubature points
    if (stateNoiseDim ~= 0)
        offsetPrediction = [svdDecomposition(covState) zeros(stateDim, stateNoiseDim); zeros(stateNoiseDim, stateDim) svdDecomposition(stateNoise.covariance)];
        cubatureSet  = cvecrep([state; stateNoise.mean], numCubPointSet1) + offsetPrediction*(sqrt(numCubPointSet1/2)*[eye(augmentDim) -eye(augmentDim)]);
    else
        offsetPrediction = svdDecomposition(covState);
        cubatureSet  = cvecrep(state, numCubPointSet1) + offsetPrediction*(sqrt(numCubPointSet1/2)*[eye(augmentDim) -eye(augmentDim)]);
    end   

    %% Propagate cubature-points through process model
    predictedState = model.stateTransitionFun(model, cubatureSet(1:stateDim, :), cubatureSet(stateDim + 1 : stateDim + stateNoiseDim, :), control1);

    predictedStateMean = sum(predictedState, 2) / numCubPointSet1;
    squareRootPredictedStateCov = (predictedState - cvecrep(predictedStateMean, numCubPointSet1)) / sqrt(numCubPointSet1);
    predictedStateCov = squareRootPredictedStateCov*squareRootPredictedStateCov'; % probably + processNoiseCov

    %% Calculate cubature points for measurement
    augmentDim = stateDim + obsNoiseDim;
    numCubPointSet2 = 2*augmentDim;
    offsetObs = [svdDecomposition(predictedStateCov) zeros(stateDim, obsNoiseDim); zeros(obsNoiseDim, stateDim) svdDecomposition(observNoise.covariance)];
    cubatureSet2 = cvecrep([predictedStateMean; observNoise.mean], numCubPointSet2) + offsetObs*(sqrt(numCubPointSet2/2)*[eye(augmentDim) -eye(augmentDim)]);

    %% Propagate through observation model
    if (model.control2InputDimension == 0); control2 = []; end
    
    predictObs = model.stateObservationFun(model, cubatureSet2(1:stateDim, :), cubatureSet2(stateDim+1:stateDim+obsNoiseDim, :), control2);
    predictObsMean = sum(predictObs, 2) / numCubPointSet2;

    %% Measurement update
    x = (cubatureSet2(1:stateDim, :) - cvecrep(predictedStateMean, numCubPointSet2)) / sqrt(numCubPointSet2);
    z = (predictObs-cvecrep(predictObsMean, numCubPointSet2)) / sqrt(numCubPointSet2);

    innovationCov = z*z'+ observNoise.covariance;
    crossCov = x*z';
    filterGain = crossCov*pinv(innovationCov);

    if isempty(model.innovationModelFunc)
        inov = observation - predictObsMean;
    else
        inov = model.innovationModelFunc( model, observation, predictObsMean);
    end

    newState = predictedStateMean + filterGain*inov;
    newCovState = predictedStateCov - filterGain*innovationCov*filterGain';

    %% additional ouptut param (required for debug) 
    internal.meanPredictedState    = predictedStateMean;
    internal.predictedStateCov     = predictedStateCov;
    internal.predictedObservMean   = predictObsMean;
    internal.inov                  = inov;
    internal.predictedObservCov    = innovationCov;
    internal.filterGain            = filterGain;
end
