function [ newState, newCovState, stateNoise, observNoise, internals ] = cqkf( state, covState, stateNoise, observNoise, observation, model, control1, control2)
    % cqkf. Cubature Quadrature Kalman Filter (some kind of High-degree Cubature Kalman Filter)
    %
    %   [ newState, newCovState, stateNoise, observNoise, internals ] = cqkf( state, covState, stateNoise, observNoise, observation, model, control1, control2)
    %
    %   This filter assumes the following standard state-space model:
    %
    %     x(k) = f[x(k-1), v(k-1), u1(k-1)];
    %     z(k) = h[x(k), n(k), u2(k)],
    %
    %   where
    %       x  - is the system state;
    %       v  - the process noise;
    %       n  - the observation noise;
    %       u1 - the exogenous input to the state;
    %       f  - transition function;
    %       u2 - the exogenous input to the state observation function;
    %       z  - the noisy observation of the system.
    %
    %   Cubature points calculated as intersection of unit hyper-sphere and its axes.
    %   Quadrature points calculated as solution of Chebyshev-Laguerre polynoms with order n' and a = (n / 2 - 1).
    %
    %   INPUT
    %         state        state mean at time k-1 ( x(k-1) );
    %         covState     square root factor of matrix through Singular Value Secomposition of state covariance at time k-1;
    %         stateNoise   process noise data structure (must be of type 'gaussian' or 'combo-gaussian');
    %         observNoise  observation noise data structure (must be of type 'gaussian' or 'combo-gaussian');
    %         observation  noisy observations at time k ( z(k) );
    %         model        inference data structure, which fully describes filtration issue (generated by inferenceDataGenerator function);
    %         control1     exogenous input to state transition function starting at time k-1 ( u1(k-1) );
    %         control2     exogenous input to state observation function starting at time k  ( u2(k) ).
    %
    %   OUTPUT
    %         newState                  estimates of state starting at time k ( E[x(t)|z(1), z(2), ..., z(t)] for t = k );
    %         newCovState               estimate of square root factor of matrix through Singular value decomposition of state covariance at time k;
    %         stateNoise                process noise data structure (possibly updated);
    %         observNoise               observation noise data structure (possibly updated);
    %         internals                 <<optional>> internal variables data structure
    %           .meanPredictedState        predicted state mean ( E[x(t)|z(1), z(2), ..., z(t-1)] for t = k );
    %           .sqrtCovState              predicted of Cholesky factor of state covariance matrix at time k;
    %           .predictedObservMean       predicted observation ( E[z(k)|Z(k-1)] );
    %           .inov                      inovation signal;
    %           .sqrtObservCov             predicted of Cholesky or SVD factor of observation covariance;
    %           .filterGain                filter gain.
    %
    %% error checking
    if (nargin ~= 8 && nargin ~= 6)
        error('[ cqkf ] Not enough input arguments (should be 6 or 8).');
    end
    
    if (model.stateDimension ~= size(state, 1))
        error('[ cqkf ] Prior state dimension differs from model.stateDimension');
    end
    
    if (model.stateDimension ~= size(covState, 1))
        error('[ cqkf ] Prior state covariance dimension differs from model.stateDimension');
    end
    
    if (model.observationDimension ~= size(observation, 1));
        error('[ cqkf ] Observation dimension differs from model.observationDimension');
    end
    %%
    stateDim = model.stateDimension;
    obsDim   = model.observationDimension;
    order    = model.cqkfParams(1);
    
    if (model.controlInputDimension == 0)
        control1 = [];
    end
    if (model.control2InputDimension == 0)
        control2 = [];
    end
    
    [points, w] = cubatureQuadraturePoints(stateDim, order);
    
    %% evaluate cubature points
    numCubSet1 = 2*stateDim*order;
    weights = elrep(w, stateDim, numCubSet1);
    cubatureSet = cvecrep(state, numCubSet1) + chol(covState, 'lower')*points;
    
    %% propagate cubature-points through process model
    predictedState = model.stateTransitionFun(model, cubatureSet, cvecrep(stateNoise.mean, numCubSet1), control1);
    
    predictedStateMean = sum(predictedState.*weights, 2);
    squareRootPredictedStateCov = (predictedState - cvecrep(predictedStateMean, numCubSet1)).*weights;
    predictedStateCov = squareRootPredictedStateCov*squareRootPredictedStateCov' + stateNoise.covariance;
    
    %% evaluate cubature points for measurement
    weights2 = elrep(w, obsDim, numCubSet1);
    cubatureSet2 = cvecrep(predictedStateMean, numCubSet1) + chol(predictedStateCov, 'lower')*points;
    
    %% propagate through observation model
    predictObs = model.stateObservationFun(model, cubatureSet2, cvecrep(observNoise.mean, numCubSet1), control2);
    predictObsMean = sum(predictObs.*weights2, 2);
    
    %% measurement update
    x = (cubatureSet2 - cvecrep(predictedStateMean, numCubSet1)).*weights;
    z = (predictObs-cvecrep(predictObsMean, numCubSet1)).*weights2;
    
    innovationCov = z*z'+ observNoise.covariance;
    crossCov = x*z';
    filterGain = crossCov*pinv(innovationCov);
    
    if isempty(model.innovationModelFunc)
        inov = observation - predictObsMean;
    else
        inov = model.innovationModelFunc(model, observation, predictObsMean);
    end
    
    newState = predictedStateMean + filterGain*inov;
    newCovState = predictedStateCov - filterGain*innovationCov*filterGain';
    
    %% build additional ouptut param (required for debug)
    if nargout > 4
        internals.meanPredictedState    = predictedStateMean;
        internals.predictedStateCov     = predictedStateCov;
        internals.predictedObservMean   = predictObsMean;
        internals.inov                  = inov;
        internals.predictedObservCov    = innovationCov;
        internals.filterGain            = filterGain;
    end
end
