function [ bound ] = crlb( state, observation, initCovState, stateNoise, observNoise, model )
    % crlb. Calculates Cramer-Rao lower bound.
    %
    %   [ crm ] = crlb( state, observation, initCovState, stateNoise, observNoise, model )
    %
    %   Caluclate Crame-Rao lower bound using linearization method like EKF. For more details see:
    %   Lecture notes on state estimation of nonlinear non-Gaussian stochastic systems. Miroslav S?imandl.
    %   Department of Cybernetics Faculty of Applied Sciences University of West Bohemia in Pilsen.
    %
    %   Following state space model using:
    %
    %     x(k) = f[x(k-1), v(k-1), u1(k-1)];
    %     z(k) = h[x(k), n(k), u2(k)],
    %
    %   where:
    %       x  - is the system state;
    %       v  - the process noise;
    %       n  - the observation noise;
    %       u1 - the exogenous input to the state;
    %       f  - the transition function;
    %       u2 - the exogenous input to the state observation function;
    %       z  - the noisy observation of the system.
    %
    %   INPUT:
    %         state             state mean at time 1:k ( x(1:k) );
    %         initCovState      state covariance at time 1 ( Px(k-1), allow to initialize algorithm );
    %         stateNoise        process noise data structure;
    %         observNoise       observation noise data structure;
    %         observation       noisy observations at time 1:k ( z(1:k) );
    %         model             inference data structure, which fully describes filtration issue (generated by inferenceDataGenerator function).
    %
    %   OUTPUT
    %         bound     calculated Cramer-Rao lower bound at time 1:k.
    %
    %% error checking
    narginchk(6, 6);
    
    if (size(state, 2) ~= size(observation, 2))
        error('[ crlb ] second (which tipically related with time) dimesnsion mismatch between state matrix and observation matrix');
    end
    
    if (model.stateDimension ~= size(state, 1))
        error('[ crlb ] Prior state dimension differs from model.stateDimension');
    end
    
    if ( model.stateDimension ~= size(initCovState, 1))
        error('[ crlb ] Prior state covariance dimension differs from model.stateDimension');
    end
    
    if (model.observationDimension ~= size(observation, 1))
        error('[ crlb ] Observation dimension differs from model.observationDimension');
    end
    %%
    control1 = []; % probably, must be argument
    control2 = []; % probably, must be argument
    
    length      = size(state, 2);
    boundBucket = zeros(model.stateDimension, length);
    covState    = initCovState;
    
    for i = 1:length
        x = state(:, i);
        
        [f, g] = model.linearize(model, x, stateNoise.mean, observNoise.mean, control1, control2, 'F', 'G');
        
        predictState     = model.stateTransitionFun( model, x, stateNoise.mean, control1);
        predictStateCov  = f * covState * f' + g * stateNoise.covariance * g';
        
        [c, h] = model.linearize(model, predictState, stateNoise.mean, observNoise.mean, control1, control2, 'C', 'H');
        
        predictObservCov    = c * predictStateCov * c' + h * observNoise.covariance * h';
        gain                = predictStateCov * c' / predictObservCov;        
        covState            = predictStateCov - gain * predictObservCov * gain';
        
        boundBucket(:, i) = diag(stateCov);
    end
    
    bound = mean(boundBucket, 2).^0.5;
end
