function [stateNew, stateSqrtCovNew, stateNoise, observNoise, internal ] = srcdkf(state, sqrtCovState, stateNoise, observNoise, observation, model, ctrl1, ctrl2)
    % srcdkf. Square Root Central Difference Kalman Filter (Sigma-Point Kalman Filter variant).
    %
    %   [stateNew, stateSqrtCovNew, stateNoise, observNoise, internals ] = srcdkf(state, sqrtCovState, stateNoise, observNoise, observation, model, ctrl1, ctrl2)
    %
    %   This filter assumes the following standard state-space model:
    %
    %     x(k) = f[x(k-1), v(k-1), u1(k-1)];
    %     z(k) = h[x(k), n(k), u2(k)],
    %
    %   where
    %       x   is the system state;
    %       v  	the process noise;
    %       n  	the observation noise;
    %       u1 	the exogenous input to the state;
    %       f  	transition function;
    %       u2 	the exogenous input to the state observation function;
    %       z  	the noisy observation of the system.
    %
    %   INPUT
    %         state         state mean at time k-1 ( x(k-1) );
    %         sqrtCovState  upper triangle metrix from Cholesky decomposition of state covariance at time k-1 ( chol(Px(k-1)) );
    %         stateNoise    process noise data structure (must be of type 'gaussian' or 'combo-gaussian');
    %         observNoise   observation noise data structure (must be of type 'gaussian' or 'combo-gaussian');
    %         observation   noisy observations at time k ( z(k) );
    %         model         inference data structure, which fully describes filtration issue (generated by inferenceDataGenerator function);
    %         ctrl1         exogenous input to state transition function at time k-1 ( u1(k-1) );
    %         ctrl2         exogenous input to state observation function at time k ( u2(k) ).
    %
    %   OUTPUT
    %         stateNew                	estimates of state starting at time k ( E[x(t)|z(1), z(2), ..., z(t)] for t = k );
    %         sqrtCovState              estimate of Cholesky factor of state covariance matrix at time k;
    %         stateNoise                process noise data structure (possibly updated);
    %         observNoise               observation noise data structure (possibly updated);
    %         internal                  <<optional>> internal variables data structure:
    %           .meanPredictedState        predicted state mean ( E[x(t)|z(1), z(2),..., z(t-1)] for t = k );
    %           .sqrtCovState              predicted of Cholesky factor of state covariance matrix at time k;
    %           .predictedObservMean       predicted observation ( E[z(k)|Z(k-1)] );
    %           .inov                      inovation signal;
    %           .sqrtObservCov             predicted of Cholesky factor of observation covariance;
    %           .filterGain                filter gain.
    %
    %   Required model fields:
    %         .spkfParams: SPKF parameters = [h] with h: CDKF scale factor / difference step size.
    %
    %% error checking
    if (nargin ~= 8 && nargin ~= 6)
        error('[ srcdkf ] Not enough input arguments (should be 6 or 8).');
    end
    
    if (model.stateDimension ~= size(state, 1))
        error('[ srcdkf ] Prior state dimension differs from model.stateDimension');
    end
    
    if (model.stateDimension ~= size(sqrtCovState, 1))
        error('[ srcdkf ] Prior state covariance dimension differs from model.stateDimension');
    end
    
    if (model.observationDimension ~= size(observation, 1))
        error('[ srcdkf ] Observation dimension differs from model.observationDimension');
    end
    
    %%
    stateDim       = model.stateDimension;
    stateNoiseDim  = model.processNoiseDimension;
    obsNoiseDim    = model.observationNoiseDimension;
    h              = model.spkfParams;
    hh             = h^2;
    
    % sigma-point weights set 1
    w1 = [(hh - stateDim - stateNoiseDim) / hh   1 / (2*hh);
        1 / (2*h)                             sqrt(hh-1) / (2*hh)];
    
    % sigma-point weights set 2
    w2      = w1;
    w2(1,1) = (hh - stateDim - obsNoiseDim)/hh;
    
    numSigmaPointSet1 = 2*(stateDim + stateNoiseDim) + 1;
    numSigmaPointSet2 = 2*(stateDim + obsNoiseDim) + 1;
    
    if (model.controlInputDimension  == 0)
        ctrl1 = [];
    end
    
    if (model.control2InputDimension == 0)
        ctrl2 = zeros(0, numSigmaPointSet2);
    end
    
    %% time update (prediction)
    if stateNoise.covariance == 0
        sigmaPointSet1 = cvecrep(state, numSigmaPointSet1);
        offsetSet1     = sqrtCovState;
    else
        sigmaPointSet1 = cvecrep([state; stateNoise.mean], numSigmaPointSet1);
        offsetSet1     = [sqrtCovState zeros(stateDim, stateNoiseDim); zeros(stateNoiseDim, stateDim) stateNoise.covariance];
    end
    sigmaPointSet1(:, 2:numSigmaPointSet1) = sigmaPointSet1(:, 2:numSigmaPointSet1) + [h*offsetSet1 -h*offsetSet1];
    
    %% propagate sigma-points through process model
    predictState = model.stateTransitionFun(model, sigmaPointSet1(1:stateDim, :), sigmaPointSet1(stateDim + 1 : stateDim + stateNoiseDim, :), ctrl1);
    meanPredictState = w1(1, 1) * predictState(:, 1) + w1(1, 2) * sum(predictState(:, 2:numSigmaPointSet1), 2);
    
    a = w1(2, 1) * ( predictState(:, 2:stateDim + stateNoiseDim+1) - predictState(:, stateDim+stateNoiseDim + 2 : numSigmaPointSet1) ) ;
    b = w1(2, 2) * ( predictState(:, 2:stateDim + stateNoiseDim+1) + predictState(:, stateDim+stateNoiseDim + 2 : numSigmaPointSet1) - ...
        cvecrep(2*predictState(:, 1), stateDim + stateNoiseDim));
    
    [~, sqrtPredictStateCov] = qr([a b]', 0);
    sqrtPredictStateCov= sqrtPredictStateCov';
    
    sigmaPointSet2 = cvecrep([meanPredictState; observNoise.mean], numSigmaPointSet2);
    offsetSet2     = [sqrtPredictStateCov zeros(stateDim, obsNoiseDim); zeros(obsNoiseDim, stateDim) observNoise.covariance];
    sigmaPointSet2(:, 2:numSigmaPointSet2) = sigmaPointSet2(:,2:numSigmaPointSet2) + [h*offsetSet2 -h*offsetSet2];
    
    %% propagate sigma-points through observation model
    predictedObs = model.stateObservationFun(model, sigmaPointSet2(1:stateDim, :), sigmaPointSet2(stateDim+1:stateDim+obsNoiseDim, :), ctrl2);
    meanPredictedObs = w2(1, 1) * predictedObs(:, 1) + w2(1, 2) * sum(predictedObs(:, 2:numSigmaPointSet2), 2);
    c = w2(2,1) * ( predictedObs(:, 2:stateDim + obsNoiseDim + 1) - predictedObs(:, stateDim + obsNoiseDim + 2 : numSigmaPointSet2) );
    d = w2(2,2) * ( predictedObs(:, 2:stateDim + obsNoiseDim + 1) + predictedObs(:, stateDim + obsNoiseDim + 2 : numSigmaPointSet2) - ...
        cvecrep(2*predictedObs(:, 1), stateDim + obsNoiseDim));
    
    % qr([c d]', 0);
    [~, predictedObservCov] = qr([c d observNoise.covariance]', 0);
    predictedObservCov = predictedObservCov';
    
    %% measurement update (correction)
    crossCov = sqrtPredictStateCov*c(:, 1:stateDim)';
    filterGain = (crossCov / predictedObservCov') / predictedObservCov;
    
    if isempty(model.innovationModelFunc)
        inov = observation - meanPredictedObs;
    else
        inov = model.innovationModelFunc( model, observation, meanPredictedObs);
    end
    
    stateNew = meanPredictState + filterGain*inov;
    
    [~, stateSqrtCovNew] = qr([sqrtPredictStateCov-filterGain*c(:, 1:stateDim) filterGain*c(:, stateDim+1:end) filterGain*d]', 0);
    stateSqrtCovNew = stateSqrtCovNew';
    
    %% build additional ouptut param (required for debug)
    if nargout > 4
        internal.meanPredictedState    = meanPredictState;
        internal.predictedStateCov     = sqrtPredictStateCov*sqrtPredictStateCov';
        internal.s_cov_state           = sqrtPredictStateCov;
        internal.predictedObservMean   = meanPredictedObs;
        internal.inov                  = inov;
        internal.predictedObservCov    = predictedObservCov*predictedObservCov';
        internal.filterGain            = filterGain;
    end
end