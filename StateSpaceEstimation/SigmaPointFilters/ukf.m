function [stateNew, stateCovNew, stateNoise, observNoise, internal] = ukf(state, covState, stateNoise, observNoise, observation, model, control1, control2)
    % ukf. Unscented Kalman Filter.
    %
    %   [stateNew, stateCovNew, stateNoise, observNoise, internal] = ukf(state, covState, stateNoise, observNoise, observation, model, control1, control2)
    %
    %   This filter assumes the following standard state-space model:
    %
    %     x(k) = f[x(k-1), v(k-1), u1(k-1)];
    %     z(k) = h[x(k), n(k), u2(k)],
    %
    %   where:
    %       x  - is the system state;
    %       v  - the process noise;
    %       n  - the observation noise;
    %       u1 - the exogenous input to the state;
    %       f  - the transition function;
    %       u2 - the exogenous input to the state observation function;
    %       z  - the noisy observation of the system.
    %
    %   INPUT:
    %         state             state mean at time k-1 ( x(k-1) );
    %         covState          state covariance at time k-1 ( Px(k-1) );
    %         stateNoise        process noise data structure (must be of type 'gaussian' or 'combo-gaussian');
    %         observNoise       observation noise data structure (must be of type 'gaussian' or 'combo-gaussian');
    %         observation       noisy observations starting at time k ( z(k));
    %         model             inference data structure, which fully describes filtration issue (generated by inferenceDataGenerator function);
    %         control1          exogenous input to state transition function starting at time k-1 ( u1(k-1) );
    %         control2          exogenous input to state observation function starting at time k  ( u2(k) ).
    %
    %   OUTPUT
    %         stateNew          estimates of state starting at time k ( E[x(t)|z(1), z(2), ..., z(t)] for t = k );
    %         stateCovNew       state covariance at time k;
    %         stateNoise        process noise data structure     (possibly updated);
    %         observNoise       observation noise data structure (possibly updated);
    %         internal              <<optional>> internal variables data structure
    %           .meanPredictedState         	predicted state mean ( E[x(t)|z(1), z(2), ..., z(t-1)] for t = k );
    %           .predictedStateCov              predicted state covariance;
    %           .predictedObservMean            predicted observation ( E[z(k)|Z(k-1)] );
    %           .inov                           inovation signal;
    %           .predictedObservCov             inovation covariance;
    %           .filterGain                     filter gain.
    %
    %   Required model fields:
    %         .spkfParams       SPKF parameters ([alpha beta kappa]) where:
    %           alpha               UKF scale factor;
    %           beta                UKF covariance correction factor;
    %           kappa               UKF secondary scaling parameter.
    %
    %% error checking
    if (nargin ~= 8 && nargin ~= 6)
        error('[ ukf ] Not enough input arguments (should be 6 or 8).');
    end
    
    if (model.stateDimension ~= size(state, 1))
        error('[ ukf ] Prior state dimension differs from model.stateDimension');
    end
    
    if (model.stateDimension ~= size(covState, 1));
        error('[ ukf ] Prior state covariance dimension differs from model.stateDimension');
    end
    
    if (model.observationDimension ~= size(observation, 1));
        error('[ ukf ] Observation dimension differs from model.observationDimension');
    end
    
    %% initialize filter variables & structure
    stateDim         = model.stateDimension;
    procNoiseDim     = model.processNoiseDimension;
    obserNoiseDim    = model.observationNoiseDimension;
    
    alpha = model.spkfParams(1);
    beta  = model.spkfParams(2);
    kappa = model.spkfParams(3);
    
    augmentDim  = stateDim + procNoiseDim + obserNoiseDim;
    numSigmaSet = 2*augmentDim + 1;
    lambda      = alpha^2*(augmentDim + kappa)-augmentDim;
    
    if (model.controlInputDimension == 0)
        control1 = [];
    end
    
    if (model.control2InputDimension == 0)
        control2 = [];
    end
    
    w    = [lambda 0.5 0] / (augmentDim + lambda);
    w(3) = w(1) + (1 - alpha^2) + beta;
    
    %% time update (prediction)
    % generate sigma point set
    if (procNoiseDim ~= 0)
        sigmaPoints  = cvecrep([state; stateNoise.mean; observNoise.mean], numSigmaSet);
        covStateExt  = [chol(covState, 'lower') zeros(stateDim, procNoiseDim); zeros(procNoiseDim, stateDim) chol(stateNoise.covariance, 'lower')];
        offset       = ([covStateExt zeros(stateDim+procNoiseDim, obserNoiseDim); zeros(obserNoiseDim, stateDim + procNoiseDim) chol(observNoise.covariance, 'lower')]);
    else
        sigmaPoints  = rvecrep([state observNoise.mean], numSigmaSet);
        offset       = ([chol(covState, 'lower') zeros(stateDim, obserNoiseDim); zeros(obserNoiseDim, stateDim) chol(observNoise.covariance, 'lower')]);
    end
    
    sigmaPoints(:, 2:numSigmaSet) = sigmaPoints(:, 2:numSigmaSet) + sqrt(augmentDim + lambda)*[offset -offset];
    
    % propagate sigma-points through process model
    predictState = model.stateTransitionFun(model, sigmaPoints(1:stateDim, :), sigmaPoints(stateDim + 1 : stateDim + procNoiseDim, :), control1);
    meanPredictState = w(1) * predictState(:, 1) + w(2)*sum(predictState(:, 2:numSigmaSet), 2);
    centrPredState = predictState - cvecrep(meanPredictState, numSigmaSet);
    predictedStateCov = w(3)*centrPredState(:, 1)*centrPredState(:, 1)' + w(2)*centrPredState(:, 2:numSigmaSet)*centrPredState(:, 2:numSigmaSet)';
    
    % propagate through observation model
    predictedObserv = model.stateObservationFun(model, predictState, sigmaPoints(stateDim+procNoiseDim+1 : stateDim+procNoiseDim+obserNoiseDim, :), control2);
    predictedObservMean = w(1)*predictedObserv(:, 1) + w(2)*sum(predictedObserv(:, 2:numSigmaSet), 2);
    centredPredicatedObserv = predictedObserv - cvecrep(predictedObservMean, numSigmaSet);
    predictedObservCov  = w(3)*centredPredicatedObserv(:, 1)*centredPredicatedObserv(:, 1)' + ...
        w(2)*centredPredicatedObserv(:, 2:numSigmaSet)*centredPredicatedObserv(:, 2:numSigmaSet)'...
        + observNoise.covariance;
    
    %% measurement update (correction)
    crossCov = w(3)*centrPredState(:, 1)*centredPredicatedObserv(:, 1)' + w(2)*centrPredState(:, 2:numSigmaSet)*centredPredicatedObserv(:, 2:numSigmaSet)';
    
    filterGain = crossCov / predictedObservCov;
    
    if isempty(model.innovationModelFunc)
        inov = observation - predictedObservMean;
    else
        inov = model.innovationModelFunc(model, observation, predictedObservMean);
    end
    
    stateNew    = meanPredictState + filterGain*inov;
    stateCovNew = predictedStateCov - filterGain*predictedObservCov*filterGain';
    
    %% build additional ouptut param (required for debug)
    if nargout > 4
        internal.meanPredictedState    = meanPredictState;
        internal.predictedStateCov     = predictedStateCov;
        internal.predictedObservMean   = predictedObservMean;
        internal.inov                  = inov;
        internal.predictedObservCov    = predictedObservCov;
        internal.filterGain            = filterGain;
    end
end
