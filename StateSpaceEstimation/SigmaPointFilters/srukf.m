function [stateNew, stateSqrtCovNew, stateNoise, observNoise, internal] = srukf(state, sqrtCovState, stateNoise, observNoise, observation, model, ctrl1, ctrl2)
    % srukf. Square Root Unscented Kalman Filter (variant of Sigma-Point Filter).
    %
    %   [stateNew, stateSqrtCovNew, stateNoise, observNoise, internal] = srukf(state, sqrtCovState, stateNoise, observNoise, observation, model, ctrl1, ctrl2)
    %
    %   This filter assumes the following standard state-space model:
    %
    %     x(k) = f[x(k-1), v(k-1), u1(k-1)];
    %     z(k) = h[x(k), n(k), u2(k)]
    %
    %   where:
    %       x   is the system state;
    %       v   the process noise;
    %       n   the observation noise;
    %       u1  the exogenous input to the state;
    %       f   the transition function;
    %       u2  the exogenous input to the state observation function;
    %       z   the noisy observation of the system.
    %
    %   INPUT
    %         state         state mean at time k-1 ( x(k-1) );
    %         sqrtCovState  upper triangle metrix from Cholesky decomposition of state covariance at time k-1 ( chol(Px(k-1)) );
    %         stateNoise    process noise data structure (must be of type 'gaussian' or 'combo-gaussian');
    %         observNoise   observation noise data structure (must be of type 'gaussian' or 'combo-gaussian');
    %         observation   noisy observations at time k ( z(k) );
    %         model         inference data structure, which fully describes filtration issue (generated by inferenceDataGenerator function);
    %         ctrl1         exogenous input to state transition function at time k-1 ( u1(k-1) );
    %         ctrl2         exogenous input to state observation function at time k ( u2(k) ).
    %
    %   OUTPUT
    %         stateNew                	estimates of state starting at time k ( E[x(t)|z(1), z(2), ..., z(t)] for t = k );
    %         sqrtCovState              estimate of Cholesky factor of state covariance matrix at time k;
    %         stateNoise                process noise data structure (possibly updated);
    %         observNoise               observation noise data structure (possibly updated);
    %         internal                  <<optional>> internal variables data structure:
    %           .meanPredictedState        predicted state mean ( E[x(t)|z(1), z(2),..., z(t-1)] for t = k );
    %           .sqrtCovState              predicted of Cholesky factor of state covariance matrix at time k;
    %           .predictedObservMean       predicted observation ( E[z(k)|Z(k-1)] );
    %           .inov                      inovation signal;
    %           .sqrtObservCov             predicted of Cholesky factor of observation covariance;
    %           .filterGain                filter gain.
    %
    %   Required gssModel fields:
    %         .spkfParams    SPKF parameters = [alpha beta kappa] with:
    %             alpha         SRUKF scale factor;
    %             beta          SRUKF covariance correction factor;
    %             kappa         SRUKF secondary scaling parameter.
    %
    %%
    
    stateDim         = model.stateDimension;
    procNoiseDim     = model.processNoiseDimension;
    obserNoiseDim    = model.observationNoiseDimension;
    observDim        = model.observationDimension;
    %% error checking
    if (nargin ~= 8 && nargin ~= 6)
        error('[ srukf ] Not enough input arguments (should be 6 or 8).');
    end
    
    if (model.stateDimension ~= size(state, 1))
        error('[ srukf ] Prior state dimension differs from model.stateDimension');
    end
    
    if (model.stateDimension ~= size(sqrtCovState, 1))
        error('[ srukf ] Prior state covariance dimension differs from model.stateDimension');
    end
    
    if (model.observationDimension ~= size(observation, 1))
        error('[ srukf ] Observation dimension differs from model.observationDimension');
    end
    
    %% extract UKF scaling parameters
    alpha = model.spkfParams(1);
    beta  = model.spkfParams(2);
    kappa = model.spkfParams(3);
    
    augmentStateDim = stateDim + procNoiseDim + obserNoiseDim;
    numSigmaPoints  = 2*augmentStateDim + 1;
    kappa           = alpha^2*(augmentStateDim + kappa)-augmentStateDim;
    
    if (model.controlInputDimension == 0)
        ctrl1 = [];
    end
    
    if (model.control2InputDimension == 0)
        ctrl2 = [];
    end
    
    w      = [kappa 0.5 0] / (augmentStateDim + kappa);
    w(3)   = w(1) + (1 - alpha^2) + beta;
    
    sqrtW         = w;
    sqrtW(1:2)    = sqrt(w(1:2));
    sqrtW(3)      = sqrt(abs(w(3)));
    
    %% generate sigma point set
    if procNoiseDim ~= 0
        sigmaPoints  = cvecrep([state; stateNoise.mean; observNoise.mean], numSigmaPoints);
        covExtProcNoise = [sqrtCovState zeros(stateDim, procNoiseDim); zeros(procNoiseDim, stateDim) stateNoise.covariance];
        offset = [covExtProcNoise zeros(stateDim + procNoiseDim, obserNoiseDim); zeros(obserNoiseDim, stateDim + procNoiseDim) observNoise.covariance];
    else
        sigmaPoints  = cvecrep([state; observNoise.mean], numSigmaPoints);
        offset = [sqrtCovState zeros(stateDim, obserNoiseDim); zeros(obserNoiseDim, stateDim) observNoise.covariance];
    end
    
    sigmaPoints(:, 2:numSigmaPoints) = sigmaPoints(:, 2:numSigmaPoints) + sqrt(augmentStateDim + kappa)*[offset -offset];
    
    %% propagate sigma-points through process model
    predictState = model.stateTransitionFun(model, sigmaPoints(1:stateDim, :), sigmaPoints(stateDim + 1 : stateDim + procNoiseDim, :), ctrl1);
    meanPredictState = w(1) * predictState(:, 1) + w(2)*sum(predictState(:, 2:numSigmaPoints), 2);
    centredPredictState = predictState - cvecrep(meanPredictState, numSigmaPoints);
    
    % QR update of state Cholesky factor
    % predictedStateCov
    [~, sqrtCovState] = qr((sqrtW(2) * centredPredictState(:, 2:numSigmaPoints))', 0);
    
    % deal with possible negative zero'th covariance weight
    if w(3) > 0
        sqrtCovState = cholupdate(sqrtCovState, sqrtW(3)*centredPredictState(:, 1),'+');
    else
        sqrtCovState = cholupdate(sqrtCovState, sqrtW(3)*centredPredictState(:, 1),'-');
    end
    
    %% propagate through observation model
    predictObs = model.stateObservationFun(model, predictState, sigmaPoints(stateDim + procNoiseDim + 1 : stateDim + procNoiseDim+obserNoiseDim, :), ctrl2);
    predictObsMean = w(1)*predictObs(:, 1) + w(2)*sum(predictObs(:, 2:numSigmaPoints), 2);
    centredPredictObs = predictObs - cvecrep(predictObsMean, numSigmaPoints);
    
    % QR update of observation error Cholesky factor (sy is the UPPER Cholesky factor)
    [~, sy] = qr([(sqrtW(2) * centredPredictObs(:, 2:numSigmaPoints))'; observNoise.covariance], 0);
    
    if w(3) > 0
        sy = cholupdate(sy, sqrtW(3)*centredPredictObs(:, 1), '+');
    else
        sy = cholupdate(sy, sqrtW(3)*centredPredictObs(:, 1), '-');
    end
    
    % coz matrix should be lower triangle
    sqrtObservCov = sy';
    
    %% measurement update
    crossCov = w(3)*centredPredictState(:,1)*centredPredictObs(:,1)' + w(2)*centredPredictState(:,2:numSigmaPoints)*centredPredictObs(:,2:numSigmaPoints)';
    
    filterGain = (crossCov/sqrtObservCov')/sqrtObservCov;
    
    if isempty(model.innovationModelFunc)
        inov = observation - predictObsMean;
    else
        inov = model.innovationModelFunc(model, observation, predictObsMean);
    end
    
    stateNew = meanPredictState + filterGain*inov;
    
    % correct covariance. This is equivalent to: Px = Px_ - KG*Py*KG';
    covUpdate = filterGain*sqrtObservCov;
    
    for j = 1:observDim
        sqrtCovState = cholupdate(sqrtCovState, covUpdate(:, j), '-');
    end
    
    stateSqrtCovNew = sqrtCovState';
    
    %% build additional ouptut param (required for debug)
    if nargout > 4
        internal.meanPredictedState    = meanPredictState;
        internal.predictedStateCov     = sqrtCovState*sqrtCovState';
        internal.s_cov_state           = sqrtCovState;
        internal.predictedObservMean   = predictObsMean;
        internal.inov                  = inov;
        internal.predictedObservCov    = sqrtObservCov*sqrtObservCov';
        internal.filterGain            = filterGain;
    end
end
