function [newState, newCovState, stateNoise, observNoise, internal ] = sghqf(state, covState, stateNoise, observNoise, observation, model, control1, control2)
    % SGHQF Sparse Gauss–Hermite Quadrature Filter.
    %   Sparse Gauss–Hermite quadrature filter is proposed using a sparse-grid method for multidimensional
    %   numerical integration in the Bayesian estimation framework. The conventional Gauss–Hermite quadrature filter is
    %   computationally expensive for multidimensional problems, because the number of Gauss–Hermite quadrature
    %   points increases exponentially with the dimension. The number of sparse-grid points of the computationally efficient
    %   sparse Gauss–Hermite quadrature filter, however, increases only polynomially with the dimension. In addition, it is
    %   proven in this paper that the unscented Kalman filter using the suggested optimal parameter is a subset of the sparse
    %   Gauss–Hermite quadrature filter.
    %
    %   For more details see "Sparse Gauss–Hermite Quadrature Filter with Application to Spacecraft Attitude Estimation"
    %   By Bin Jia, Ming Xin and Yang Cheng
    %   JOURNAL OF GUIDANCE, CONTROL, AND DYNAMICS Vol. 34, No. 2, March–April 2011
    %
    %   [newState, newCovState, stateNoise, observNoise, internal ] = sghqf(state, covState, stateNoise, observNoise, observation, model, control1, control2)
    %
    %   This filter assumes the following standard state-space model:
    %
    %     x(k) = f[x(k-1), v(k-1), U1(k-1)]
    %     y(k) = h[x(k), n(k), U2(k)]
    %
    %   where:
    %       x  - is the system state,
    %       v  - the process noise,
    %       n  - the observation noise,
    %       u1 - the exogenous input to the state
    %       f  - the transition function,
    %       u2 - the exogenous input to the state observation function
    %       y  - the noisy observation of the system.
    %
    %   INPUT
    %         state         state mean at time k-1          ( xh(k-1) )
    %         covState      state covariance at time k-1    ( Px(k-1) )
    %         stateNoise    state noise data structure     (must be of type 'gaussian' or 'combo-gaussian')
    %         observNoise   observation noise data structure (must be of type 'gaussian' or 'combo-gaussian')
    %         observation   noisy observations starting at time k ( y(k),y(k+1),...,y(k+N-1) )
    %         control1      exogenous input to state transition function starting at time k-1 ( u1(k-1),u1(k),...,u1(k+N-2) )
    %         control2      exogenous input to state observation function starting at time k  ( u2(k),u2(k+1),...,u2(k+N-1) )
    %         model         inference data structure generated by GENINFDS function.
    %
    %   OUTPUT
    %         newState     estimates of state starting at time k ( E[x(t)|y(1),y(2),...,y(t)] for t=k,k+1,...,k+N-1 )
    %         newStateCov  state covariance
    %         stateNoise   state noise data structure     (possibly updated)
    %         observNoise  observation noise data structure (possibly updated)
    %
    %         internal                      <<optional>> internal variables data structure
    %           .meanPredictedState         	predicted state mean ( E[x(t)|y(1),y(2),..y(t-1)] for t=k,k+1,...,k+N-1 )
    %           .predictedStateCov              predicted state covariance
    %           .predictedObservMean            predicted observation ( E[y(k)|Y(k-1)] )
    %           .inov                           inovation signal
    %           .predictedObservCov             inovation covariance
    %           .filterGain                     Kalman gain
    %
    
    %% error checking
    if (nargin ~= 8 && nargin ~= 6); error(' [ ghqf ] Not enough input arguments (should be 6 or 8).'); end
    
    if (model.stateDimension ~= size(state, 1)); error('[ ghqf ] Prior state dimension differs from model.stateDimension'); end
    
    if (model.stateDimension ~= size(covState, 1)); error('[ ghqf ] Prior state covariance dimension differs from model.stateDimension'); end
    
    if (model.observationDimension ~= size(observation, 1)); error('[ ghqf ] Observation dimension differs from model.observationDimension'); end
    
    %%
    stateDim = model.stateDimension;
    obsDim   = model.observationDimension;
    order    = model.sghkfParams(1);
    manner   = model.sghkfParams(2);
    
    if (model.controlInputDimension == 0); control1 = []; end
    if (model.control2InputDimension == 0); control2 = []; end
    
    [set, weights] = sparseGaussHermiteRule(order, stateDim, manner);
    weights1 = rvecrep(weights, stateDim);
    weights2 = rvecrep(weights, obsDim);
    
    %% evaluate cubature points
    numPoints = size(set, 2);
    pointSet  = cvecrep(state, numPoints) + svdDecomposition(covState)*set;
    
    %% propagate quadrature points through process model
    predictedState = model.stateTransitionFun(model, pointSet, cvecrep(stateNoise.mean, numPoints), control1);
    
    predictedStateMean = sum(predictedState.*weights1, 2);
    squareRootPredictedStateCov = (predictedState - cvecrep(predictedStateMean, numPoints)).*weights1;
    predictedStateCov = squareRootPredictedStateCov*squareRootPredictedStateCov' + stateNoise.covariance;
    
    %% evaluate cubature points for measurement
    pointSet2 = cvecrep(predictedStateMean, numPoints) + svdDecomposition(predictedStateCov)*set;
    
    %% propagate through observation model
    predictObs = model.stateObservationFun(model, pointSet2, cvecrep(observNoise.mean, numPoints), control2);
    predictObsMean = sum(predictObs.*weights2, 2);
    
    %% measurement update
    x = (pointSet2 - cvecrep(predictedStateMean, numPoints)).*weights1;
    z = (predictObs - cvecrep(predictObsMean, numPoints)).*weights2;
    
    innovationCov = z*z'+ observNoise.covariance;
    crossCov = x*z';
    filterGain = crossCov*pinv(innovationCov);
    
    if isempty(model.innovationModelFunc)
        inov = observation - predictObsMean;
    else
        inov = model.innovationModelFunc(model, observation, predictObsMean);
    end
    
    newState = predictedStateMean + filterGain*inov;
    newCovState = predictedStateCov - filterGain*innovationCov*filterGain';
    
    %% additional ouptut param (required for debug)
    internal.meanPredictedState    = predictedStateMean;
    internal.predictedStateCov     = predictedStateCov;
    internal.predictedObservMean   = predictObsMean;
    internal.inov                  = inov;
    internal.predictedObservCov    = innovationCov;
    internal.filterGain            = filterGain;
end
